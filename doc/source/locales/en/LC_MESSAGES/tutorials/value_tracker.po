# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, jkjkil4
# This file is distributed under the same license as the JAnim package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: JAnim \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-23 22:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/tutorials/value_tracker.rst:2
msgid "ValueTracker 与自定义数据"
msgstr "ValueTracker and Custom Data"

#: ../../source/tutorials/value_tracker.rst:7
msgid "基础用法"
msgstr "Basic Usage"

#: ../../source/tutorials/value_tracker.rst:9
msgid "在 JAnim 中，可以使用 :class:`~.ValueTracker` 来变化和跟踪自定义数据的值。"
msgstr ""
"In JAnim, you can use :class:`~.ValueTracker` to change and track custom "
"data values."

#: ../../source/tutorials/value_tracker.rst:11
msgid "例如，下面这个例子我们已经在 :ref:`item_updater_usage` 中提到过："
msgstr ""
"For example, the following example was already mentioned in "
":ref:`item_updater_usage`:"

#: ../../source/tutorials/value_tracker.rst:13
#, python-brace-format
msgid ""
"tr = ValueTracker(0)\n"
"txt = Text('0.00', font_size=40).show()\n"
"\n"
"self.forward()\n"
"self.play(\n"
"    Succession(\n"
"        tr.anim.set_value(4),\n"
"        tr.anim.set_value(2.5),\n"
"        tr.anim.set_value(10)\n"
"    ),\n"
"    ItemUpdater(\n"
"        txt,\n"
"        lambda p: Text(f'{tr.current().get_value():.2f}', font_size=40),\n"
"        duration=3\n"
"    )\n"
")\n"
"self.forward()"
msgstr ""
"tr = ValueTracker(0)\n"
"txt = Text('0.00', font_size=40).show()\n"
"\n"
"self.forward()\n"
"self.play(\n"
"    Succession(\n"
"        tr.anim.set_value(4),\n"
"        tr.anim.set_value(2.5),\n"
"        tr.anim.set_value(10)\n"
"    ),\n"
"    ItemUpdater(\n"
"        txt,\n"
"        lambda p: Text(f'{tr.current().get_value():.2f}', font_size=40),\n"
"        duration=3\n"
"    )\n"
")\n"
"self.forward()"

#: ../../source/tutorials/value_tracker.rst:35
msgid "在这个例子中，我们可以注意到 :class:`~.ValueTracker` 的两个主要功能："
msgstr "In this example, we can note two main features of :class:`~.ValueTracker`:"

#: ../../source/tutorials/value_tracker.rst:37
msgid ""
"通过 :meth:`~.ValueTracker.set_value` 方法，可以设置数据的新值，并且这个变化可以通过 ``.anim`` "
"创建为动画"
msgstr ""
"Using :meth:`~.ValueTracker.set_value`, you can set a new value, and the "
"change can be animated with ``.anim``"

#: ../../source/tutorials/value_tracker.rst:39
msgid "通过 :meth:`~.ValueTracker.get_value` 方法，可以获取数据的值"
msgstr "Using :meth:`~.ValueTracker.get_value`, you can retrieve the value"

#: ../../source/tutorials/value_tracker.rst:43
msgid ""
"在 Updater 中，需要使用 :meth:`~.Item.current` 方法来获取当前的动画状态中的 "
":class:`~.ValueTracker` 实例，即通过"
msgstr ""
"In an Updater, you need to use :meth:`~.Item.current` to get the "
":class:`~.ValueTracker` instance in the current animation state, i.e. via"

#: ../../source/tutorials/value_tracker.rst:45
msgid "tr.current().get_value()"
msgstr "tr.current().get_value()"

#: ../../source/tutorials/value_tracker.rst:49
msgid "来获取当前动画中的值。"
msgstr "to get the current animated value."

#: ../../source/tutorials/value_tracker.rst:51
msgid "关于 :meth:`~.Item.current` 的介绍，详见 :ref:`current_usage` 。"
msgstr "For :meth:`~.Item.current`, see :ref:`current_usage`."

#: ../../source/tutorials/value_tracker.rst:53
msgid ":class:`~.ValueTracker` 不仅支持这种简单数值的变化与跟踪，还支持各种复杂结构，例如列表，字典，``numpy`` 数组等："
msgstr ""
":class:`~.ValueTracker` not only supports simple numeric changes and "
"tracking, but also complex structures such as lists, dicts, and ``numpy``"
" arrays:"

#: ../../source/tutorials/value_tracker.rst:13
#, python-brace-format
msgid ""
"tr = ValueTracker({\n"
"    'position': ORIGIN,\n"
"    'rotate': 0,\n"
"    'color': [1.0, 0.5, 0.0],\n"
"    'radius': 0.2\n"
"})\n"
"dots = DotCloud(\n"
"    *(\n"
"        [x, y, 0]\n"
"        for x in range(-1, 2)\n"
"        for y in range(-1, 2)\n"
"    )\n"
").show()\n"
"\n"
"def dots_updater(data: DotCloud, p=None) -> None:\n"
"    value = tr.current().get_value()\n"
"    data.points.move_to(value['position']).rotate(value['rotate'])\n"
"    data.color.set(value['color'])\n"
"    data.radius.set(value['radius'])\n"
"\n"
"dots_updater(dots)\n"
"\n"
"self.forward()\n"
"self.play(\n"
"    Succession(\n"
"        tr.anim.set_value({\n"
"            'position': UP * 1.5,\n"
"            'rotate': PI / 4,\n"
"            'color': [0.0, 0.5, 1.0],\n"
"            'radius': 0.5\n"
"        }),\n"
"        tr.anim.set_value({\n"
"            'position': LEFT * 1.5,\n"
"            'rotate': -PI / 4,\n"
"            'color': [1.0, 0.0, 0.5],\n"
"            'radius': 0.1\n"
"        }),\n"
"        tr.anim.set_value({\n"
"            'position': ORIGIN,\n"
"            'rotate': 0,\n"
"            'color': [1.0, 0.5, 0.0],\n"
"            'radius': 0.2\n"
"        }),\n"
"        tr.anim.update_value({\n"
"            'rotate': TAU,\n"
"            'color': [1.0, 1.0, 1.0]\n"
"        })\n"
"    ),\n"
"    DataUpdater(dots, dots_updater, duration=4)\n"
")\n"
"self.forward()"
msgstr ""
"tr = ValueTracker({\n"
"    'position': ORIGIN,\n"
"    'rotate': 0,\n"
"    'color': [1.0, 0.5, 0.0],\n"
"    'radius': 0.2\n"
"})\n"
"dots = DotCloud(\n"
"    *(\n"
"        [x, y, 0]\n"
"        for x in range(-1, 2)\n"
"        for y in range(-1, 2)\n"
"    )\n"
").show()\n"
"\n"
"def dots_updater(data: DotCloud, p=None) -> None:\n"
"    value = tr.current().get_value()\n"
"    data.points.move_to(value['position']).rotate(value['rotate'])\n"
"    data.color.set(value['color'])\n"
"    data.radius.set(value['radius'])\n"
"\n"
"dots_updater(dots)\n"
"\n"
"self.forward()\n"
"self.play(\n"
"    Succession(\n"
"        tr.anim.set_value({\n"
"            'position': UP * 1.5,\n"
"            'rotate': PI / 4,\n"
"            'color': [0.0, 0.5, 1.0],\n"
"            'radius': 0.5\n"
"        }),\n"
"        tr.anim.set_value({\n"
"            'position': LEFT * 1.5,\n"
"            'rotate': -PI / 4,\n"
"            'color': [1.0, 0.0, 0.5],\n"
"            'radius': 0.1\n"
"        }),\n"
"        tr.anim.set_value({\n"
"            'position': ORIGIN,\n"
"            'rotate': 0,\n"
"            'color': [1.0, 0.5, 0.0],\n"
"            'radius': 0.2\n"
"        }),\n"
"        tr.anim.update_value({\n"
"            'rotate': TAU,\n"
"            'color': [1.0, 1.0, 1.0]\n"
"        })\n"
"    ),\n"
"    DataUpdater(dots, dots_updater, duration=4)\n"
")\n"
"self.forward()"

#: ../../source/tutorials/value_tracker.rst:111
msgid ""
"在这个例子中，我们使用了一个包含多个字段的字典作为 :class:`~.ValueTracker` 的值，并在 Updater "
"中根据这些字段来更新点云的位置，旋转，颜色和半径。"
msgstr ""
"In this example, we use a dictionary with multiple fields as the "
":class:`~.ValueTracker` value, and in the Updater we update the point "
"cloud's position, rotation, color, and radius based on these fields."

#: ../../source/tutorials/value_tracker.rst:113
msgid ""
"相比于 :meth:`~.ValueTracker.set_value` 需要提供完整字段，我们也可以用 "
":meth:`~.ValueTracker.update_value` 方法来只更新部分字段的值，而不影响其他字段。"
msgstr ""
"Compared to :meth:`~.ValueTracker.set_value` which requires full fields, "
"you can use :meth:`~.ValueTracker.update_value` to update only some "
"fields without affecting the others."

#: ../../source/tutorials/value_tracker.rst:116
msgid "高级用法"
msgstr "Advanced Usage"

#: ../../source/tutorials/value_tracker.rst:118
msgid "除了基本的数值和结构， :class:`~.ValueTracker` 还支持沿用组件类型，以及注册自定义类型的处理。"
msgstr ""
"Besides basic values and structures, :class:`~.ValueTracker` also "
"supports reusing component types and registering custom types."

#: ../../source/tutorials/value_tracker.rst:122
msgid "说实话，高级用法的应用场景非常罕见，除非你在开发新的组件或者需要跟踪非常复杂的数据，否则大多数情况下使用基础用法就足够了。"
msgstr ""
"To be honest, advanced usage is rare; unless you are developing new "
"components or tracking very complex data, basic usage is sufficient in "
"most cases."

#: ../../source/tutorials/value_tracker.rst:124
msgid ""
"因此以下两个小标题 :ref:`use_component_types` 和 :ref:`register_custom_types` "
"的内容仅作简单介绍。"
msgstr ""
"Therefore the following sections :ref:`use_component_types` and "
":ref:`register_custom_types` are only briefly introduced."

#: ../../source/tutorials/value_tracker.rst:129
msgid "沿用组件类型"
msgstr "Reusing Component Types"

#: ../../source/tutorials/value_tracker.rst:131
msgid ""
"首先我们需要知道，所有 :class:`~.Component` 的子类都可以直接作为 :class:`~.ValueTracker` "
"的值类型，例如："
msgstr ""
"First, note that all subclasses of :class:`~.Component` can be used "
"directly as value types for :class:`~.ValueTracker`, for example:"

#: ../../source/tutorials/value_tracker.rst:133
msgid ":class:`~.Cmpt_Points`"
msgstr ":class:`~.Cmpt_Points`"

#: ../../source/tutorials/value_tracker.rst:135
msgid ":class:`~.Cmpt_VPoints`"
msgstr ":class:`~.Cmpt_VPoints`"

#: ../../source/tutorials/value_tracker.rst:137
msgid ":class:`~.Cmpt_Rgbas`"
msgstr ":class:`~.Cmpt_Rgbas`"

#: ../../source/tutorials/value_tracker.rst:139
msgid "..."
msgstr "..."

#: ../../source/tutorials/value_tracker.rst:141
msgid ""
"虽然说我们可以将组件类型 :class:`~.Cmpt_Points` 作为值类型直接使用，但是对于实际来讲，还是直接操作 "
":class:`~.Points` 物件或者含义更具体的物件，并在需要时 :meth:`~.Item.current` 会更方便。"
msgstr ""
"Although you can use a component type like :class:`~.Cmpt_Points` as the "
"value type directly, in practice it is more convenient to operate on "
":class:`~.Points` items or more specific items, and use "
":meth:`~.Item.current` when needed."

#: ../../source/tutorials/value_tracker.rst:146
msgid "注册自定义类型"
msgstr "Register Custom Types"

#: ../../source/tutorials/value_tracker.rst:148
msgid ""
"如果有一个类没有定义 :class:`~.SupportsTracking` 所需求的三大件 :meth:`~.Component.copy` 、"
" :meth:`~.Component.not_changed` 以及 :meth:`~.Component.interpolate` ， "
"那么我们可以通过 :meth:`~.Cmpt_Data.register_funcs` 来注册这些方法，从而让这个类可以作为 "
":class:`~.ValueTracker` 的值类型。具体使用方法可参考内置类型的注册。"
msgstr ""
"If a class does not define the three methods required by "
":class:`~.SupportsTracking` (:meth:`~.Component.copy`, "
":meth:`~.Component.not_changed`, and :meth:`~.Component.interpolate`), "
"you can register them with :meth:`~.Cmpt_Data.register_funcs` so the "
"class can be used as a value type for :class:`~.ValueTracker`. See the "
"registration of built-in types for usage."

#: ../../source/tutorials/value_tracker.rst:151
msgid ""
"另外，我们可以通过 :meth:`~.Cmpt_Data.register_update_func` 来注册供 "
":meth:`~.ValueTracker.update_value` 使用的更新方法。具体使用方法可参考内置的 ``dict`` 类型的注册。"
msgstr ""
"Additionally, you can use :meth:`~.Cmpt_Data.register_update_func` to "
"register an update method for :meth:`~.ValueTracker.update_value`. See "
"the built-in ``dict`` registration for usage."

#: ../../source/tutorials/value_tracker.rst:154
msgid "添加自定义的物件数据"
msgstr "Add Custom Item Data"

#: ../../source/tutorials/value_tracker.rst:156
msgid ""
":class:`~.ValueTracker` 的特性完全基于 :class:`~.Cmpt_Data` 组件实现， "
"你完全可以将其组件添加到任意物件中，从而让你的自定义物件能够灵活地跟踪额外的数据变化，并依据你地需求灵活使用"
msgstr ""
"The features of :class:`~.ValueTracker` are entirely based on the "
":class:`~.Cmpt_Data` component. You can add this component to any item, "
"allowing your custom item to flexibly track extra data changes and use "
"them as needed."

#: ../../source/tutorials/value_tracker.rst:159
msgid "为了添加这种组件，使用 :class:`~.CustomData` 即可，就像这样："
msgstr "To add this component, use :class:`~.CustomData` like this:"

#: ../../source/tutorials/value_tracker.rst:13
#, python-brace-format
msgid ""
"class PhysicalBlock(Square):\n"
"    physic = CustomData()\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"        self.physic.set({\n"
"            'speed': ORIGIN,    # 默认静止\n"
"            'accel': ORIGIN,    # 并且没有加速度\n"
"        })\n"
"\n"
"    def do_physic(self, dt: float) -> Self:\n"
"        # 根据 `speed` 与 `accel` 更新物件位置\n"
"        value = self.physic.get()\n"
"\n"
"        avg_speed = value['speed'] + 0.5 * value['accel'] * dt\n"
"        shift = avg_speed * dt\n"
"\n"
"        self.physic.update({ 'speed': value['speed'] + value['accel'] * "
"dt })\n"
"        self.points.shift(shift)\n"
"\n"
"        return self\n"
"\n"
"    def do_physic_updater(self):\n"
"        # 将 `do_physic` 包装为 Updater\n"
"        return StepUpdater(self, lambda data, p: data.do_physic(p.dt))\n"
"\n"
"\n"
"class TestPhysicalBlock(Timeline):\n"
"    def construct(self):\n"
"        block = PhysicalBlock()\n"
"        block.points.to_border(DL)\n"
"\n"
"        # 实时显示物块的运动向量\n"
"        def vectors_updater(p):\n"
"            cur = block.current()\n"
"            pos = cur.points.box.center\n"
"            value = cur.physic.get()\n"
"\n"
"            vec_speed = Vector(value['speed'] * 0.5, color=BLUE)\n"
"            vec_speed.points.shift(pos)\n"
"            vec_accel = Vector(value['accel'] * 0.5, color=RED)\n"
"            vec_accel.points.shift(pos)\n"
"\n"
"            return Group(vec_speed, vec_accel)\n"
"\n"
"        self.prepare(ItemUpdater(None, vectors_updater, "
"duration=FOREVER))\n"
"\n"
"        # 物块运动以及参数变更\n"
"        self.play(block.do_physic_updater())\n"
"        block.physic.set({ 'speed': np.array([4, 6, 0]), 'accel': DOWN * "
"4 })\n"
"        self.play(block.do_physic_updater(), duration=2)\n"
"        block.physic.update({ 'accel': LEFT * 6 })\n"
"        self.play(block.do_physic_updater(), duration=2)"
msgstr ""
"class PhysicalBlock(Square):\n"
"    physic = CustomData()\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"        self.physic.set({\n"
"            'speed': ORIGIN,    # stationary by default\n"
"            'accel': ORIGIN,    # and has no acceleration\n"
"        })\n"
"\n"
"    def do_physic(self, dt: float) -> Self:\n"
"        # Update item position based on `speed` and `accel`\n"
"        value = self.physic.get()\n"
"\n"
"        avg_speed = value['speed'] + 0.5 * value['accel'] * dt\n"
"        shift = avg_speed * dt\n"
"\n"
"        self.physic.update({ 'speed': value['speed'] + value['accel'] * "
"dt })\n"
"        self.points.shift(shift)\n"
"\n"
"        return self\n"
"\n"
"    def do_physic_updater(self):\n"
"        # Wrap `do_physic` as an Updater\n"
"        return StepUpdater(self, lambda data, p: data.do_physic(p.dt))\n"
"\n"
"\n"
"class TestPhysicalBlock(Timeline):\n"
"    def construct(self):\n"
"        block = PhysicalBlock()\n"
"        block.points.to_border(DL)\n"
"\n"
"        # Display block's motion vectors in real time\n"
"        def vectors_updater(p):\n"
"            cur = block.current()\n"
"            pos = cur.points.box.center\n"
"            value = cur.physic.get()\n"
"\n"
"            vec_speed = Vector(value['speed'] * 0.5, color=BLUE)\n"
"            vec_speed.points.shift(pos)\n"
"            vec_accel = Vector(value['accel'] * 0.5, color=RED)\n"
"            vec_accel.points.shift(pos)\n"
"\n"
"            return Group(vec_speed, vec_accel)\n"
"\n"
"        self.prepare(ItemUpdater(None, vectors_updater, "
"duration=FOREVER))\n"
"\n"
"        # Block motion and parameter changes\n"
"        self.play(block.do_physic_updater())\n"
"        block.physic.set({ 'speed': np.array([4, 6, 0]), 'accel': DOWN * "
"4 })\n"
"        self.play(block.do_physic_updater(), duration=2)\n"
"        block.physic.update({ 'accel': LEFT * 6 })\n"
"        self.play(block.do_physic_updater(), duration=2)"

#: ../../source/tutorials/value_tracker.rst:220
msgid ""
"其中的 ``physic = CustomData()`` 就是我们添加的自定义数据组件，它的用法和 "
":class:`~.ValueTracker` 十分相似："
msgstr ""
"The ``physic = CustomData()`` here is the custom data component we added,"
" and its usage is very similar to :class:`~.ValueTracker`:"

#: ../../source/tutorials/value_tracker.rst:222
msgid "通过 :meth:`~.Cmpt_Data.set` 方法设置数据的值"
msgstr "Use :meth:`~.Cmpt_Data.set` to set the data value"

#: ../../source/tutorials/value_tracker.rst:224
msgid "通过 :meth:`~.Cmpt_Data.get` 方法获取数据的值"
msgstr "Use :meth:`~.Cmpt_Data.get` to get the data value"

#: ../../source/tutorials/value_tracker.rst:226
msgid "通过 :meth:`~.Cmpt_Data.update` 方法更新数据的部分字段"
msgstr "Use :meth:`~.Cmpt_Data.update` to update parts of the data"

#: ../../source/tutorials/value_tracker.rst:228
msgid "可以像这样完善其类型注解："
msgstr "You can refine its type annotations like this:"

#: ../../source/tutorials/value_tracker.rst:230
#, fuzzy
msgid ""
"from typing import TypedDict\n"
"\n"
"class PhysicData(TypedDict):\n"
"    speed: np.ndarray\n"
"    accel: np.ndarray\n"
"\n"
"class PhysicalBlock(Square):\n"
"    physic = CustomData[Self, PhysicData]()\n"
"\n"
"    ..."
msgstr ""
"class PhysicData(TypedDict):\n"
"    speed: np.ndarray\n"
"    accel: np.ndarray\n"
"\n"
"class PhysicalBlock(Square):\n"
"    physic = CustomData[Self, PhysicData]()\n"
"\n"
"    ..."

#: ../../source/tutorials/value_tracker.rst:245
msgid "类型注解中的 ``Self`` 是为了让组件的 ``.r`` 正常运作"
msgstr ""
"The ``Self`` in the type annotation is to make the component's ``.r`` "
"work properly"

